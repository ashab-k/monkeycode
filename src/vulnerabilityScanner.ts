import axios from 'axios';
import { GoModule, Vulnerability } from './types';

export class VulnerabilityScanner {
    private static readonly GO_VULN_DB_API = 'https://vuln.go.dev/v1/vulns';

    public static async scanDependencies(modules: GoModule[]): Promise<Map<string, Vulnerability[]>> {
        const vulnerabilities = new Map<string, Vulnerability[]>();
        
        try {
            // Process each module
            for (const module of modules) {
                console.log(`Scanning module: ${module.path}@${module.version}`);
                
                try {
                    // Query the Go Vulnerability Database
                    const response = await axios.get(`${this.GO_VULN_DB_API}`, {
                        params: {
                            module: module.path
                        },
                        headers: {
                            'Accept': 'application/json'
                        }
                    });
                    
                    if (response.data && Array.isArray(response.data)) {
                        const moduleVulns = response.data
                            .filter(vuln => this.isVulnerableVersion(module.version, vuln))
                            .map(vuln => ({
                                id: vuln.id || 'unknown',
                                summary: vuln.summary || 'No summary available',
                                details: vuln.details || 'No details available',
                                aliases: vuln.aliases || [],
                                severity: this.determineSeverity(vuln),
                                published: new Date(vuln.published || vuln.modified || new Date()),
                                modified: new Date(vuln.modified || vuln.published || new Date()),
                                affectedVersions: vuln.affected || []
                            }));

                        if (moduleVulns.length > 0) {
                            vulnerabilities.set(module.path, moduleVulns);
                            console.log(`Found ${moduleVulns.length} vulnerabilities for ${module.path}`);
                        } else {
                            console.log(`No vulnerabilities found for ${module.path}`);
                        }
                    } else {
                        console.log(`No vulnerability data available for ${module.path}`);
                    }
                } catch (error) {
                    if (axios.isAxiosError(error)) {
                        if (error.response?.status === 404) {
                            console.log(`No vulnerability data found for module ${module.path}`);
                        } else {
                            console.error(`Error scanning module ${module.path}:`, error.message);
                        }
                    } else {
                        console.error(`Error processing module ${module.path}:`, error);
                    }
                    // Continue with other modules even if one fails
                }
            }
        } catch (error) {
            console.error('Error during vulnerability scan:', error);
            if (axios.isAxiosError(error)) {
                if (error.response?.status === 404) {
                    throw new Error('Vulnerability database endpoint not found. The API may have changed.');
                } else if (error.response?.status === 403) {
                    throw new Error('Access to vulnerability database denied. Please try again later.');
                } else {
                    throw new Error(`Failed to access vulnerability database: ${error.message}`);
                }
            }
            throw new Error('Failed to complete vulnerability scan');
        }

        return vulnerabilities;
    }

    private static determineSeverity(vuln: any): Vulnerability['severity'] {
        // Try to determine severity from various fields
        const severity = vuln.severity?.toLowerCase() || 
                        vuln.cvss?.severity?.toLowerCase() || 
                        'unknown';
        
        switch (severity) {
            case 'critical':
            case 'high':
            case 'medium':
            case 'low':
                return severity;
            default:
                return 'unknown';
        }
    }

    private static isVulnerableVersion(version: string, vuln: any): boolean {
        // Remove 'v' prefix if present for comparison
        const moduleVersion = version.startsWith('v') ? version.substring(1) : version;
        
        // Check if the version is in the affected range
        if (vuln.affected) {
            for (const affected of vuln.affected) {
                if (affected.module === vuln.module) {
                    // Check version ranges
                    for (const range of affected.ranges || []) {
                        if (range.type === 'SEMVER') {
                            // Check if version is in the affected range
                            const fixedVersions = range.fixed || [];
                            if (fixedVersions.length > 0) {
                                const latestFixed = fixedVersions[fixedVersions.length - 1];
                                // Simple version comparison for now
                                // TODO: Implement proper semver range checking
                                if (moduleVersion < latestFixed) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }
} 