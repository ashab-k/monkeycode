import axios, { AxiosError } from "axios";
import {
  GoModule,
  Vulnerability,
  OSVVulnerability,
  OSVResponse,
  DependencyTree,
} from "./types";
import { SeverityAnalyzer } from "./severityAnalyzer";
import { VulnerabilityFormatter } from "./vulnerabilityFormatter";
import { DependencyTreeBuilder } from "./dependencyTreeBuilder";
import * as vscode from "vscode";

export class VulnerabilityScanner {
  private static readonly OSV_API = "https://api.osv.dev/v1/querybatch";
  private static readonly OSV_VULN_API = "https://api.osv.dev/v1/vulns";

  private static async makeApiRequest(url: string, data: any, retries = 3, method: 'GET' | 'POST' = 'POST'): Promise<any> {
    const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));
    
    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        const config = {
          timeout: 15000, // 15 second timeout
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          }
        };

        const response = method === 'POST' 
          ? await axios.post(url, data, config)
          : await axios.get(url, config);

        return response;
      } catch (error: unknown) {
        const isLastAttempt = attempt === retries;
        const isTimeout = error instanceof AxiosError && (
          error.code === 'ECONNABORTED' || 
          error.message.includes('timeout')
        );
        const isNetworkError = error instanceof AxiosError && (
          error.code === 'ECONNREFUSED' || 
          error.code === 'ENOTFOUND'
        );
        
        if (isLastAttempt) {
          if (isTimeout) {
            throw new Error(`API request timed out after ${retries} attempts. Please check your internet connection and try again.`);
          } else if (isNetworkError) {
            throw new Error(`Network error: Could not connect to the vulnerability database. Please check your internet connection and try again.`);
          } else if (error instanceof Error) {
            throw new Error(`API request failed: ${error.message}`);
          } else {
            throw new Error('API request failed with unknown error');
          }
        }

        // Log retry attempt
        console.log(`API request failed (attempt ${attempt}/${retries}). Retrying in ${attempt * 2} seconds...`);
        if (isTimeout || isNetworkError) {
          await delay(attempt * 2000); // Exponential backoff
        } else {
          throw error; // Don't retry for other types of errors
        }
      }
    }
  }

  public static async scanDependencies(modules: GoModule[]): Promise<{
    vulnerabilities: Map<string, Vulnerability[]>;
    dependencyTree: DependencyTree;
  }> {
    try {
      console.log('Starting dependency scan for', modules.length, 'modules');
      
      // Build dependency tree
      const dependencyTree = await DependencyTreeBuilder.buildTree(modules);
      console.log('Built dependency tree with', dependencyTree.size, 'nodes');

      // Prepare batch query
      const queries = this.prepareBatchQuery(modules);
      console.log('Prepared batch query for', queries.length, 'packages');

      // Make API request with retry logic
      const response = await this.makeApiRequest(this.OSV_API, { queries }, 3, 'POST');
      
      if (!response.data?.results) {
        throw new Error('Invalid response from vulnerability database');
      }

      // Collect all vulnerability IDs
      const vulnIds = new Set<string>();
      response.data.results.forEach((result: any) => {
        if (result.vulns) {
          result.vulns.forEach((vuln: any) => {
            if (vuln.id) vulnIds.add(vuln.id);
          });
        }
      });

      console.log('Found vulnerability IDs:', Array.from(vulnIds));

      // Fetch full details for each vulnerability
      const vulnDetails = new Map<string, OSVVulnerability>();
      for (const id of vulnIds) {
        try {
          console.log(`Fetching details for ${id}...`);
          const detailResponse = await this.makeApiRequest(
            `${this.OSV_VULN_API}/${id}`,
            null,
            3,
            'GET'
          );
          if (detailResponse.data) {
            vulnDetails.set(id, detailResponse.data);
            console.log(`Got details for ${id}`);
          }
        } catch (error) {
          console.error(`Error fetching details for ${id}:`, error);
        }
      }

      // Process results with full details
      const vulnerabilities = await this.processResultsWithDetails(
        response.data.results,
        modules,
        vulnDetails
      );
      console.log('Found vulnerabilities for', vulnerabilities.size, 'modules');

      return { vulnerabilities, dependencyTree };
    } catch (error) {
      // Log the full error for debugging
      console.error('Error scanning dependencies:', error);
      
      // Show user-friendly error message
      if (error instanceof Error) {
        if (error.message.includes('timeout') || error.message.includes('network')) {
          vscode.window.showErrorMessage(
            'Failed to scan dependencies: Network error. Please check your internet connection and try again.',
            'Retry'
          ).then(selection => {
            if (selection === 'Retry') {
              vscode.commands.executeCommand('monkeycode.scanDependencies');
            }
          });
        } else {
          vscode.window.showErrorMessage(
            `Failed to scan dependencies: ${error.message}`,
            'Retry'
          ).then(selection => {
            if (selection === 'Retry') {
              vscode.commands.executeCommand('monkeycode.scanDependencies');
            }
          });
        }
      } else {
        vscode.window.showErrorMessage(
          'Failed to scan dependencies: An unexpected error occurred',
          'Retry'
        ).then(selection => {
          if (selection === 'Retry') {
            vscode.commands.executeCommand('monkeycode.scanDependencies');
          }
        });
      }
      
      // Return empty results instead of throwing
      return {
        vulnerabilities: new Map(),
        dependencyTree: new Map()
      };
    }
  }

  private static prepareBatchQuery(modules: GoModule[]) {
    return modules.map((module) => ({
      package: {
        ecosystem: "Go",
        name: module.path,
      },
      version: module.version.startsWith("v")
        ? module.version.substring(1)
        : module.version,
    }));
  }

  private static async queryOSVAPI(
    queries: any[]
  ): Promise<{ results: OSVResponse[] }> {
    const response = await axios.post<{ results: OSVResponse[] }>(
      this.OSV_API,
      { queries },
      {
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
        },
      }
    );
    return response.data;
  }

  private static async processResults(
    results: any[],
    modules: GoModule[]
  ): Promise<Map<string, Vulnerability[]>> {
    const vulnerabilities = new Map<string, Vulnerability[]>();
    
    for (let i = 0; i < results.length; i++) {
      const result = results[i];
      const module = modules[i];
      
      if (result.vulns && result.vulns.length > 0) {
        console.log(`\nProcessing vulnerabilities for ${module.path}:`);
        console.log('Raw vulnerability data:', JSON.stringify(result.vulns, null, 2));
        
        const moduleVulns = result.vulns.map((vuln: any) => {
          // Get severity information first
          const severityInfo = SeverityAnalyzer.analyzeSeverity(vuln);
          console.log(`\nProcessed vulnerability ${vuln.id}:`, {
            rawVuln: vuln,
            severityInfo
          });
          
          return {
            id: vuln.id || 'unknown',
            summary: vuln.summary || 'No summary available',
            details: vuln.details || 'No details available',
            severity: severityInfo.severity || 'unknown',
            published: new Date(vuln.published || vuln.modified || new Date()),
            modified: new Date(vuln.modified || vuln.published || new Date()),
            aliases: vuln.aliases || []
          };
        });
        
        // Add the vulnerabilities to the map
        vulnerabilities.set(module.path, moduleVulns);
        console.log(`Added ${moduleVulns.length} vulnerabilities for ${module.path}`);
      }
    }
    
    return vulnerabilities;
  }

  private static async processVulnerabilities(
    vulns: OSVVulnerability[]
  ): Promise<Vulnerability[]> {
    const vulnDetails = await Promise.all(
      vulns.map(async (vuln) => {
        try {
          const detailResponse = await axios.get<OSVVulnerability>(
            `${this.OSV_VULN_API}/${vuln.id}`,
            {
              headers: {
                Accept: "application/json",
              },
            }
          );
          return detailResponse.data;
        } catch (error) {
          console.error(`Error fetching details for ${vuln.id}:`, error);
          return vuln;
        }
      })
    );

    return vulnDetails.map((vuln: OSVVulnerability) => {
      // Extract summary from details if not available
      const summary = this.extractSummary(vuln);

      // Get severity information
      const severityInfo = SeverityAnalyzer.analyzeSeverity(vuln);

      // Format the details
      const details = VulnerabilityFormatter.formatVulnerabilityDetails(
        vuln,
        severityInfo.details
      );

      return {
        id: vuln.id || "unknown",
        summary: summary,
        details: details,
        aliases: vuln.aliases || [],
        severity: severityInfo.severity,
        published: new Date(vuln.published || vuln.modified || new Date()),
        modified: new Date(vuln.modified || vuln.published || new Date()),
        affectedVersions: vuln.affected || [],
      };
    });
  }

  private static extractSummary(vuln: OSVVulnerability): string {
    if (vuln.summary) return vuln.summary;

    if (vuln.details) {
      const firstLine = vuln.details
        .split("\n")
        .find((line) => line.trim().length > 0);
      if (firstLine) {
        return firstLine.trim();
      }
    }

    return "No summary available";
  }

  private static handleError(error: any): never {
    console.error("Error during vulnerability scan:", error);
    if (axios.isAxiosError(error)) {
      if (error.response?.status === 404) {
        throw new Error(
          "OSV API endpoint not found. The API may have changed."
        );
      } else if (error.response?.status === 403) {
        throw new Error("Access to OSV API denied. Please try again later.");
      } else {
        console.error("API Error Response:", error.response?.data);
        throw new Error(`Failed to access OSV API: ${error.message}`);
      }
    }
    throw new Error("Failed to complete vulnerability scan");
  }

  private static async processResultsWithDetails(
    results: any[],
    modules: GoModule[],
    vulnDetails: Map<string, OSVVulnerability>
  ): Promise<Map<string, Vulnerability[]>> {
    const vulnerabilities = new Map<string, Vulnerability[]>();
    
    for (let i = 0; i < results.length; i++) {
      const result = results[i];
      const module = modules[i];
      
      if (result.vulns && result.vulns.length > 0) {
        console.log(`\nProcessing vulnerabilities for ${module.path}:`);
        
        const moduleVulns = result.vulns.map((vuln: any) => {
          // Get full details if available
          const fullDetails = vulnDetails.get(vuln.id) || vuln;
          console.log(`\nProcessing vulnerability ${vuln.id}:`, {
            summary: fullDetails.summary,
            severity: fullDetails.severity,
            databaseSeverity: fullDetails.database_specific?.severity,
            ecosystemSeverity: fullDetails.ecosystem_specific?.severity
          });
          
          // Get severity information
          const severityInfo = SeverityAnalyzer.analyzeSeverity(fullDetails);
          
          return {
            id: vuln.id || 'unknown',
            summary: fullDetails.summary || 'No summary available',
            details: fullDetails.details || 'No details available',
            severity: severityInfo.severity || 'unknown',
            published: new Date(fullDetails.published || fullDetails.modified || new Date()),
            modified: new Date(fullDetails.modified || fullDetails.published || new Date()),
            aliases: fullDetails.aliases || [],
            affected: fullDetails.affected?.map((affected: any) => ({
              package: {
                name: affected.package.name,
                ecosystem: affected.package.ecosystem,
                purl: affected.package.purl
              },
              ranges: affected.ranges.map((range: any) => ({
                type: range.type,
                events: range.events.map((event: any) => ({
                  introduced: event.introduced,
                  fixed: event.fixed
                }))
              }))
            }))
          };
        });
        
        // Add the vulnerabilities to the map
        vulnerabilities.set(module.path, moduleVulns);
        console.log(`Added ${moduleVulns.length} vulnerabilities for ${module.path}`);
      }
    }
    
    return vulnerabilities;
  }
}
