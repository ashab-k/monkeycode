import axios from "axios";
import {
  GoModule,
  Vulnerability,
  OSVVulnerability,
  OSVResponse,
  DependencyTree,
} from "./types";
import { SeverityAnalyzer } from "./severityAnalyzer";
import { VulnerabilityFormatter } from "./vulnerabilityFormatter";
import { DependencyTreeBuilder } from "./dependencyTreeBuilder";

export class VulnerabilityScanner {
  private static readonly OSV_API = "https://api.osv.dev/v1/querybatch";
  private static readonly OSV_VULN_API = "https://api.osv.dev/v1/vulns";

  public static async scanDependencies(modules: GoModule[]): Promise<{
    vulnerabilities: Map<string, Vulnerability[]>;
    dependencyTree: DependencyTree;
  }> {
    const vulnerabilities = new Map<string, Vulnerability[]>();

    try {
      // Build dependency tree
      const dependencyTree = await DependencyTreeBuilder.buildTree(modules);

      // Prepare batch query
      const queries = this.prepareBatchQuery(modules);
      console.log("Querying OSV API with:", JSON.stringify(queries, null, 2));

      // Query the OSV API
      const response = await this.queryOSVAPI(queries);

      // Process results
      await this.processResults(modules, response, vulnerabilities);

      return { vulnerabilities, dependencyTree };
    } catch (error) {
      this.handleError(error);
      throw error;
    }
  }

  private static prepareBatchQuery(modules: GoModule[]) {
    return modules.map((module) => ({
      package: {
        ecosystem: "Go",
        name: module.path,
      },
      version: module.version.startsWith("v")
        ? module.version.substring(1)
        : module.version,
    }));
  }

  private static async queryOSVAPI(
    queries: any[]
  ): Promise<{ results: OSVResponse[] }> {
    const response = await axios.post<{ results: OSVResponse[] }>(
      this.OSV_API,
      { queries },
      {
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
        },
      }
    );
    return response.data;
  }

  private static async processResults(
    modules: GoModule[],
    response: { results: OSVResponse[] },
    vulnerabilities: Map<string, Vulnerability[]>
  ): Promise<void> {
    if (!response.results || !Array.isArray(response.results)) {
      return;
    }

    for (let i = 0; i < modules.length; i++) {
      const module = modules[i];
      const result = response.results[i];

      console.log(
        `Processing results for ${module.path}@${module.version}:`,
        result.vulns
          ? `${result.vulns.length} vulnerabilities found`
          : "no vulnerabilities"
      );

      if (result.vulns && result.vulns.length > 0) {
        const moduleVulns = await this.processVulnerabilities(result.vulns);
        vulnerabilities.set(module.path, moduleVulns);

        console.log(
          `Found ${moduleVulns.length} vulnerabilities for ${module.path}`
        );
        moduleVulns.forEach((vuln) => {
          console.log(`  - ${vuln.id}: ${vuln.summary} (${vuln.severity})`);
        });
      } else {
        console.log(`No vulnerabilities found for ${module.path}`);
      }
    }
  }

  private static async processVulnerabilities(
    vulns: OSVVulnerability[]
  ): Promise<Vulnerability[]> {
    const vulnDetails = await Promise.all(
      vulns.map(async (vuln) => {
        try {
          const detailResponse = await axios.get<OSVVulnerability>(
            `${this.OSV_VULN_API}/${vuln.id}`,
            {
              headers: {
                Accept: "application/json",
              },
            }
          );
          return detailResponse.data;
        } catch (error) {
          console.error(`Error fetching details for ${vuln.id}:`, error);
          return vuln;
        }
      })
    );

    return vulnDetails.map((vuln: OSVVulnerability) => {
      // Extract summary from details if not available
      const summary = this.extractSummary(vuln);

      // Get severity information
      const severityInfo = SeverityAnalyzer.analyzeSeverity(vuln);

      // Format the details
      const details = VulnerabilityFormatter.formatVulnerabilityDetails(
        vuln,
        severityInfo.details
      );

      return {
        id: vuln.id || "unknown",
        summary: summary,
        details: details,
        aliases: vuln.aliases || [],
        severity: severityInfo.severity,
        published: new Date(vuln.published || vuln.modified || new Date()),
        modified: new Date(vuln.modified || vuln.published || new Date()),
        affectedVersions: vuln.affected || [],
      };
    });
  }

  private static extractSummary(vuln: OSVVulnerability): string {
    if (vuln.summary) return vuln.summary;

    if (vuln.details) {
      const firstLine = vuln.details
        .split("\n")
        .find((line) => line.trim().length > 0);
      if (firstLine) {
        return firstLine.trim();
      }
    }

    return "No summary available";
  }

  private static handleError(error: any): never {
    console.error("Error during vulnerability scan:", error);
    if (axios.isAxiosError(error)) {
      if (error.response?.status === 404) {
        throw new Error(
          "OSV API endpoint not found. The API may have changed."
        );
      } else if (error.response?.status === 403) {
        throw new Error("Access to OSV API denied. Please try again later.");
      } else {
        console.error("API Error Response:", error.response?.data);
        throw new Error(`Failed to access OSV API: ${error.message}`);
      }
    }
    throw new Error("Failed to complete vulnerability scan");
  }
}
